import * as THREE from 'three';
import * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js';
import { blocks, blockDefs, getBlockDef, getBlockFaceUVs } from './blockRegistry.js';

// Constants for world generation
export const CHUNK_SIZE = 16;  // Width/depth of a chunk in blocks
export const WORLD_HEIGHT = 128; // Total world height
export const SEA_LEVEL = 62;  // Height of water/sea level
export const GROUND_LEVEL = 64; // Average terrain height (used by worker)

// Simple Cube Geometry (reused for all standard blocks)
const unitCubeGeo = new THREE.BoxGeometry(1, 1, 1);

// Placeholder for world generation and block management
export class World {
    constructor(scene, textureAtlas, uvMap) {
        this.scene = scene;
        this.textureAtlas = textureAtlas; // The main texture atlas
        this.uvMap = uvMap;           // Map of texture names to UV coords
        this.chunks = {};             // Chunk data { data: chunkDataArray, state: 'unloaded'|'generating'|'generated'|'rendered'|'error', mesh: null }
        this.renderedChunks = new Set(); // Track which chunk KEYS have been rendered (meshed)
        this.renderDistance = 4;      // Number of chunks to load/render in each direction
        this.worldSeed = Math.random() * 1000000 | 0; // Random world seed

        // Chunk loading/generation management
        this.chunkQueue = []; // Priority queue of chunks { key, x, z, priority } TO BE REQUESTED from worker
        this.chunksPerFrame = 2; // Max new generation requests to SEND per frame (rate limiting)
        this.generatingChunks = new Set(); // Track chunk KEYS currently being generated by the worker
        this.initialChunkKeys = new Set(); // Keep track of keys needed for initial load
        this.initialLoadDataComplete = false; // Flag when all initial data is received
        this.initialLoadRenderComplete = false; // Flag when initial chunks are rendered
        this.initialLoadPromises = {}; // Use map for promises now { chunkKey: resolveFn }

        // Safety mechanisms for player positioning
        this.isSafeToApplyGravity = false;  // Flag to suspend gravity during initial world gen
        this.lastSafePosition = null;       // Store the last known safe position
        this.lastPlayerChunk = { x: null, z: null }; // Last known player chunk coords

        // Initialize the Web Worker
        this.worker = new Worker('./src/worldWorker.js', { type: 'module' });
        this.setupWorkerCommunication();

        // Create a base material using the atlas
        this.baseMaterial = new THREE.MeshLambertMaterial({
            map: this.textureAtlas,
            side: THREE.FrontSide, // Only render front faces
            alphaTest: 0.1, // Prevent transparent parts of textures rendering black outlines
            transparent: true, // Allow transparency (e.g., leaves, glass),
        });
    }

    // Setup communication with the worker
    setupWorkerCommunication() {
        // Send initialization data to the worker
        this.worker.postMessage({
            type: 'init',
            payload: {
                CHUNK_SIZE,
                WORLD_HEIGHT,
                SEA_LEVEL,
                GROUND_LEVEL,
                worldSeed: this.worldSeed,
                blocks // Pass the block enum/constants
            }
        });

        // Handle messages received from the worker
        this.worker.onmessage = (event) => {
            const { type, payload } = event.data;

            if (type === 'result') {
                const { chunkKey, chunkData } = payload;
                // console.log(`Main received chunk data for ${chunkKey}`);

                // Mark as no longer generating
                this.generatingChunks.delete(chunkKey);

                // Store the generated data and mark state
                this.chunks[chunkKey] = { data: chunkData, state: 'generated' };

                 // Immediately try to render if it's needed (part of initial load or near player)
                const [cx, cz] = chunkKey.split(',').map(Number);
                if (this.initialChunkKeys.has(chunkKey) || this.isChunkNearPlayer(cx, cz)) {
                     this.renderChunk(cx, cz); // Render it now
                }

                // Resolve the promise if this was part of the initial load
                const promiseResolver = this.initialLoadPromises[chunkKey];
                if (promiseResolver) {
                    promiseResolver(); // Resolve the promise for this specific chunk
                    delete this.initialLoadPromises[chunkKey]; // Clean up map entry
                    // Check if ALL initial data is now loaded
                    this.checkInitialLoadDataComplete();
                }

            } else if (type === 'error') {
                console.error(`Worker error for chunk ${payload.chunkKey}:`, payload.message);
                this.generatingChunks.delete(payload.chunkKey);
                 // Mark as error state
                 this.chunks[payload.chunkKey] = { data: null, state: 'error' };

                // Handle initial load failure - treat as loaded but failed
                 const promiseResolver = this.initialLoadPromises[payload.chunkKey];
                if (promiseResolver) {
                    console.warn(`Initial chunk ${payload.chunkKey} failed to generate, continuing load...`);
                    promiseResolver(); // Resolve anyway to not block loading forever
                    delete this.initialLoadPromises[payload.chunkKey];
                    this.checkInitialLoadDataComplete(); // Check if others finished
                }
            }
        };

        this.worker.onerror = (error) => {
            console.error('Unhandled Worker Error:', error);
            // Handle potential worker crash, maybe try to restart it?
        };
    }

    // Helper to check if chunk coords are near the last known player coords
    isChunkNearPlayer(cx, cz) {
        if (this.lastPlayerChunk.x === null || this.lastPlayerChunk.z === null) {
            // If player position unknown, assume true only if near origin (for initial load case)
            return Math.abs(cx) <= this.renderDistance && Math.abs(cz) <= this.renderDistance;
        }
        const playerChunkX = this.lastPlayerChunk.x;
        const playerChunkZ = this.lastPlayerChunk.z;
        const dx = Math.abs(cx - playerChunkX);
        const dz = Math.abs(cz - playerChunkZ);
        return dx <= this.renderDistance && dz <= this.renderDistance;
    }

    // Creates the geometry for a standard cube block with correct UVs
    createBlockGeometry(blockId) {
        const geo = unitCubeGeo.clone(); // Clone the base geometry
        const uvs = []; // We will build the UV array manually

        // Map faces (order depends on BoxGeometry creation: px, nx, py, ny, pz, nz)
        // Corresponds to: right, left, top, bottom, front, back
        const faceOrder = ['right', 'left', 'top', 'bottom', 'front', 'back'];

        for (const face of faceOrder) {
            const faceUVs = getBlockFaceUVs(blockId, face);
            if (faceUVs) {
                // Correct UV order for THREE.BoxGeometry faces
                if (face === 'top' || face === 'bottom') {
                    // Order for Top/Bottom faces (Y +/-)
                    uvs.push(faceUVs.u0, faceUVs.v1); // BL
                    uvs.push(faceUVs.u1, faceUVs.v1); // BR
                    uvs.push(faceUVs.u0, faceUVs.v0); // TL
                    uvs.push(faceUVs.u1, faceUVs.v0); // TR
                } else {
                    // Order for Side faces (X +/-, Z +/-)
                    uvs.push(faceUVs.u0, faceUVs.v1); // BL
                    uvs.push(faceUVs.u1, faceUVs.v1); // BR
                    uvs.push(faceUVs.u0, faceUVs.v0); // TL
                    uvs.push(faceUVs.u1, faceUVs.v0); // TR
                }
            } else {
                // Fallback for missing UVs (tiny magenta square in corner)
                console.warn(`Missing UVs for block ${blockId}, face ${face}. Using fallback.`);
                const missingUVs = { u0: 0.999, v0: 0.999, u1: 1.0, v1: 1.0 }; // Tiny bottom-right corner
                uvs.push(missingUVs.u0, missingUVs.v1);
                uvs.push(missingUVs.u1, missingUVs.v1);
                uvs.push(missingUVs.u0, missingUVs.v0);
                uvs.push(missingUVs.u1, missingUVs.v0);
            }
        }
        // Replace the automatically generated UV attribute with our corrected one
        geo.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
        geo.computeVertexNormals(); // Recalculate normals
        return geo;
    }

    // Main world generation function (starts initial load)
    generate() {
        console.log(`Generating world with seed: ${this.worldSeed}`);
        this.isSafeToApplyGravity = false; // Suspend gravity
        this.initialLoadDataComplete = false;
        this.initialLoadRenderComplete = false;
        this.initialChunkKeys.clear();
        this.initialLoadPromises = {}; // Reset promises map

        // Queue initial chunks around the origin (0, 0)
        const initialLoadRadius = this.renderDistance; // Load initial area = render distance
        for (let cx = -initialLoadRadius; cx <= initialLoadRadius; cx++) {
            for (let cz = -initialLoadRadius; cz <= initialLoadRadius; cz++) {
                 const chunkKey = `${cx},${cz}`;
                const distance = Math.sqrt(cx * cx + cz * cz);
                 // Add to set of keys needed for initial load
                 this.initialChunkKeys.add(chunkKey);
                 // Queue for worker generation
                 this.queueChunkGeneration(cx, cz, distance);
            }
        }

        console.log(`Queued ${this.initialChunkKeys.size} initial chunks for generation.`);
        // Start processing the request queue (sends messages to worker gradually)
        this.processChunkRequestQueue();

        // Gravity enables when checkInitialLoadRenderComplete() passes
    }

    // Check if all initial CHUNK DATA has been received from worker
    checkInitialLoadDataComplete() {
        if (this.initialLoadDataComplete) return;

        // Check if the promises map is empty (all workers returned)
        if (Object.keys(this.initialLoadPromises).length === 0) {
             console.log("Initial chunk data generation complete.");
             this.initialLoadDataComplete = true;
             // Now we need to wait for rendering - trigger a check
             this.checkInitialLoadRenderComplete();
        }
    }

    // Check if all initial CHUNKS have been RENDERED
    checkInitialLoadRenderComplete() {
         if (this.initialLoadRenderComplete || !this.initialLoadDataComplete) return; // Already done or data not ready

         // Check if all chunks tracked in initialChunkKeys are now in 'rendered' state
         let allRendered = true;
         for (const chunkKey of this.initialChunkKeys) {
             const chunk = this.chunks[chunkKey];
             // If any initial chunk is missing, not generated, or not rendered yet, we wait
             // Treat 'error' state as rendered for purpose of unblocking, but log it.
             if (!chunk || (chunk.state !== 'rendered' && chunk.state !== 'error')) {
                 allRendered = false;
                 // console.log(`Waiting for initial chunk ${chunkKey} to render. State: ${chunk?.state}`);
                 break;
             }
              if (chunk.state === 'error') {
                  console.warn(`Initial chunk ${chunkKey} had an error, but proceeding with load.`);
              }
         }

         if (allRendered) {
             console.log("Initial chunk rendering complete. Enabling gravity.");
             this.initialLoadRenderComplete = true;
             this.isSafeToApplyGravity = true; // Safe to enable gravity now
              // At this point, we can try to set the initial safe position
             // based on the player's starting coords (usually near 0,0)
             // Let updateChunks handle setting it on the first valid ground check
         }
    }

    // Request chunk generation from the worker
    requestChunkGeneration(chunkX, chunkZ) {
        const chunkKey = `${chunkX},${chunkZ}`;

        // Check if chunk exists, is already generating, or failed
        const existingChunk = this.chunks[chunkKey];
        if (existingChunk || this.generatingChunks.has(chunkKey)) {
             // If it failed previously, maybe allow retry? For now, skip.
            // if (existingChunk && existingChunk.state === 'error') { console.log(`Skipping failed chunk ${chunkKey}`); }
            return false; // Indicate no request was sent
        }

        // Mark as generating
        this.generatingChunks.add(chunkKey);
        // Set state
        this.chunks[chunkKey] = { data: null, state: 'generating' };

        // console.log(`Requesting chunk ${chunkKey} from worker`);

        // If this is part of the initial load, create a promise for it
        if (this.initialChunkKeys.has(chunkKey) && !this.initialLoadDataComplete) {
            // Ensure promise map entry exists if somehow missed in queueChunkGeneration
             if (!this.initialLoadPromises[chunkKey]) {
                new Promise((resolve) => {
                    this.initialLoadPromises[chunkKey] = resolve;
                });
            }
        }

        // Send generation task to the worker
        this.worker.postMessage({
            type: 'generate',
            payload: {
                chunkX,
                chunkZ
                // Worker already has seed, constants, blocks from init
            }
        });
        return true; // Indicate request was sent
    }

    // Adds a chunk coordinates to the request queue (to be sent to worker later)
    queueChunkGeneration(chunkX, chunkZ, priority = 1) {
        const chunkKey = `${chunkX},${chunkZ}`;

        // Skip if chunk data exists, is generating, failed, or already in queue
        const existingChunk = this.chunks[chunkKey];
        if (existingChunk || this.generatingChunks.has(chunkKey)) {
            return;
        }
         // Check if it's already queued
        const inQueue = this.chunkQueue.some(item => item.key === chunkKey);
        if(inQueue) {
             // Optionally update priority if lower distance found
            return;
        }

        // If this chunk is needed for the initial load, set up its promise tracking
        if (this.initialChunkKeys.has(chunkKey) && !this.initialLoadDataComplete) {
             if (!this.initialLoadPromises[chunkKey]) { // Avoid overwriting if somehow already exists
                new Promise((resolve) => {
                    this.initialLoadPromises[chunkKey] = resolve; // Store the resolver function
                });
            }
        }

        // Add to the request queue
        const queueItem = { key: chunkKey, x: chunkX, z: chunkZ, priority };
        this.chunkQueue.push(queueItem);

        // Sort queue by priority (distance) - lower is better
        this.chunkQueue.sort((a, b) => a.priority - b.priority);
    }

    // Process the request queue, sending tasks to the worker gradually
    processChunkRequestQueue() {
        if (this.chunkQueue.length === 0) {
            return; // Nothing to request
        }

        let requestsSent = 0;
        while (this.chunkQueue.length > 0 && requestsSent < this.chunksPerFrame) {
            const chunkToRequest = this.chunkQueue.shift(); // Get highest priority

            // Double check state before sending request
            const chunkKey = chunkToRequest.key;
            const existingChunk = this.chunks[chunkKey];
            if (existingChunk || this.generatingChunks.has(chunkKey)) {
                continue; // Skip if it got generated/requested somehow in the meantime
            }

            // Request generation from worker
            if (this.requestChunkGeneration(chunkToRequest.x, chunkToRequest.z)) {
                 requestsSent++;
            }
        }

        // If there are still items in the queue, schedule next processing batch
        if (this.chunkQueue.length > 0) {
            requestAnimationFrame(() => this.processChunkRequestQueue());
        }
    }

    // Render a chunk (convert generated chunk data to visible meshes)
    renderChunk(chunkX, chunkZ) {
        const chunkKey = `${chunkX},${chunkZ}`;
        const chunk = this.chunks[chunkKey];

        // Ensure chunk data exists and is generated, and not already rendered
        if (!chunk || chunk.state !== 'generated' || this.renderedChunks.has(chunkKey)) {
            return;
        }

        // console.log(`Rendering chunk at (${chunkX}, ${chunkZ})`); // Reduce noise

        const chunkData = chunk.data;
        if (!chunkData) {
             console.error(`Cannot render chunk ${chunkKey}: Missing chunk data array.`);
             chunk.state = 'error'; // Mark as error
             // Check if this failed chunk affects initial load completion
             if (this.initialChunkKeys.has(chunkKey) && !this.initialLoadRenderComplete) {
                 this.checkInitialLoadRenderComplete();
             }
             return;
        }

        // --- Merged Geometry Setup ---
        const chunkGeometries = []; // Array to hold geometries of individual blocks

        // Get neighboring chunks (data only needed for visibility check)
        const neighbors = this.getNeighboringChunkData(chunkX, chunkZ);

        // --- Iterate through blocks and create geometries for visible ones ---
        for (let x = 0; x < CHUNK_SIZE; x++) {
            for (let y = 0; y < WORLD_HEIGHT; y++) {
                for (let z = 0; z < CHUNK_SIZE; z++) {
                    const blockType = chunkData[x][y][z];

                    if (blockType === blocks.AIR) continue;

                    // Check visibility against neighbors
                    if (this.isBlockVisible(chunkData, neighbors, x, y, z, blockType)) {
                        const blockGeo = this.createBlockGeometry(blockType);
                        // Apply local translation within the chunk BEFORE merging
                        blockGeo.translate(x + 0.5, y + 0.5, z + 0.5);
                        chunkGeometries.push(blockGeo);
                    }
                }
            }
        }

        // --- Merge Geometries if any exist ---
        if (chunkGeometries.length > 0) {
            // Correct check: Check the imported variable, not THREE namespace
            if (typeof BufferGeometryUtils === 'undefined' || typeof BufferGeometryUtils.mergeGeometries !== 'function') {
                console.warn("Imported BufferGeometryUtils or mergeGeometries function not found. Chunk merging disabled. Performance will be suboptimal. Using first block's geometry for chunk mesh as placeholder.");
                 // Placeholder: Use the first geometry found. This is NOT correct merging.
                 const mergedGeometry = chunkGeometries[0]; // Incorrect, but avoids error
                 // We need to translate it back to origin as the mesh position handles world offset
                 mergedGeometry.translate(-(chunkGeometries[0].parameters?.x ?? 0), -(chunkGeometries[0].parameters?.y ?? 0), -(chunkGeometries[0].parameters?.z ?? 0));


                // Create the single chunk mesh
                const chunkMesh = new THREE.Mesh(mergedGeometry, this.baseMaterial);
                // Position the chunk mesh at its world origin
                chunkMesh.position.set(chunkX * CHUNK_SIZE, 0, chunkZ * CHUNK_SIZE);
                chunkMesh.castShadow = true;
                chunkMesh.receiveShadow = true;
                chunkMesh.userData = { chunkKey: chunkKey, isChunkMesh: true };

                this.scene.add(chunkMesh);
                chunk.mesh = chunkMesh; // Store reference to the merged mesh

                 // Dispose individual geometries used in the merge
                // chunkGeometries.forEach(geo => geo.dispose()); // Dispose if merged correctly


            } else {
                // --- Correct Merging Logic (Requires THREE.BufferGeometryUtils) ---
                // Correct usage: Call the function from the imported module
                const mergedGeometry = BufferGeometryUtils.mergeGeometries(chunkGeometries, false); // Use groups = false

                 if (mergedGeometry) {
                    // Create the single chunk mesh
                    const chunkMesh = new THREE.Mesh(mergedGeometry, this.baseMaterial);
                    // Position the chunk mesh at its world origin
                    chunkMesh.position.set(chunkX * CHUNK_SIZE, 0, chunkZ * CHUNK_SIZE);
                    chunkMesh.castShadow = true;
                    chunkMesh.receiveShadow = true;
                    chunkMesh.userData = { chunkKey: chunkKey, isChunkMesh: true };

                    this.scene.add(chunkMesh);
                    chunk.mesh = chunkMesh; // Store reference to the merged mesh

                    // Dispose individual geometries used in the merge
                    chunkGeometries.forEach(geo => geo.dispose());
                 } else {
                     console.error(`Failed to merge geometries for chunk ${chunkKey}`);
                     chunk.state = 'error';
                 }
            }

        } else {
             // No visible blocks in this chunk (e.g., all air)
             // console.log(`Chunk (${chunkX}, ${chunkZ}) is empty or contains no visible blocks.`);
             chunk.mesh = null; // Ensure mesh property is null
        }


        // Mark chunk state as rendered and add key to rendered set
        chunk.state = 'rendered';
        this.renderedChunks.add(chunkKey);
        // console.log(`Rendered chunk (${chunkX}, ${chunkZ}) with ${chunkGeometries.length} visible blocks.`);

        // If this was an initial chunk, check if the initial render is now complete
         if (this.initialChunkKeys.has(chunkKey) && !this.initialLoadRenderComplete) {
             this.checkInitialLoadRenderComplete();
         }
    }

    // Get neighboring chunk data (only the data array) for visibility checks
    getNeighboringChunkData(chunkX, chunkZ) {
        const getData = (cx, cz) => {
            const key = `${cx},${cz}`;
            const chunk = this.chunks[key];
            // Return data only if generated or rendered (or errored - treat as empty)
             return (chunk && (chunk.state === 'generated' || chunk.state === 'rendered')) ? chunk.data : null;
             // Treat 'error' as null to avoid errors, means blocks at edge won't render optimally
             // return (chunk && (chunk.state === 'generated' || chunk.state === 'rendered' || chunk.state === 'error')) ? chunk.data : null;
        };
        return {
            px: getData(chunkX + 1, chunkZ), // +X neighbor
            nx: getData(chunkX - 1, chunkZ), // -X neighbor
            pz: getData(chunkX, chunkZ + 1), // +Z neighbor
            nz: getData(chunkX, chunkZ - 1), // -Z neighbor
            // Note: Top/bottom neighbours aren't needed for standard height worlds
        };
    }

    // Checks if a block needs to be rendered based on neighbors
    isBlockVisible(chunkData, neighbors, x, y, z, blockType) {
        if (y < 0 || y >= WORLD_HEIGHT) return false;

        const blockDef = getBlockDef(blockType);
        const isSelfTransparent = !blockDef || blockDef.transparent; // Air or glass etc.

        // Helper to check adjacent block type safely (within chunk or neighbor)
        const getAdjacentBlock = (dx, dy, dz) => {
            const nx = x + dx;
            const ny = y + dy;
            const nz = z + dz;

            // Out of vertical bounds? Treat as air.
            if (ny < 0 || ny >= WORLD_HEIGHT) return blocks.AIR;

            // Check within the current chunk first
            if (nx >= 0 && nx < CHUNK_SIZE && nz >= 0 && nz < CHUNK_SIZE) {
                // Handle potential out-of-bounds access if chunkData isn't fully formed (shouldn't happen here)
                try { return chunkData[nx][ny][nz]; } catch (e) { return blocks.AIR; }
            }

            // Check neighboring chunks (check neighbor exists before indexing)
             try {
                if (nx < 0 && neighbors.nx) return neighbors.nx[CHUNK_SIZE - 1][ny][nz];
                if (nx >= CHUNK_SIZE && neighbors.px) return neighbors.px[0][ny][nz];
                if (nz < 0 && neighbors.nz) return neighbors.nz[nx][ny][CHUNK_SIZE - 1];
                if (nz >= CHUNK_SIZE && neighbors.pz) return neighbors.pz[nx][ny][0];
            } catch (e) {
                // Indexing error likely means neighbor data structure is wrong, treat as air
                 console.warn(`Error accessing neighbor chunk data at ${dx},${dy},${dz} from ${x},${y},${z}`);
                 return blocks.AIR;
             }

            // If neighbor doesn't exist, treat as air (edge of loaded world)
            return blocks.AIR;
        };

        // Check all 6 neighbors
        const adjacentBlocks = [
            getAdjacentBlock(1, 0, 0),  // +X
            getAdjacentBlock(-1, 0, 0), // -X
            getAdjacentBlock(0, 1, 0),  // +Y
            getAdjacentBlock(0, -1, 0), // -Y
            getAdjacentBlock(0, 0, 1),  // +Z
            getAdjacentBlock(0, 0, -1)  // -Z
        ];

        for (const adjacentType of adjacentBlocks) {
             const adjacentDef = getBlockDef(adjacentType);
             // Visible if neighbor is Air or transparent
             if (!adjacentDef || adjacentDef.transparent) {
                 // Special case: Don't render face between two transparent blocks (e.g. water next to water) unless one is air
                 // Simplified: If self is also transparent, only render if neighbor is AIR
                 if (isSelfTransparent && adjacentType !== blocks.AIR) {
                     // Allow transparent blocks like glass next to water? Check specific block types if needed.
                     // For now, only render if neighbor is AIR.
                     continue;
                 }
                 return true; // Visible!
             }
        }

        return false; // Surrounded by solid blocks
    }

    // Simplified check: Is block type transparent?
    isBlockTransparent(blockType) {
        const blockDef = getBlockDef(blockType);
        // Treat unknown blocks as non-transparent (or air which is handled separately)
        return blockDef ? blockDef.transparent : false;
    }

    // Get just the block type ID from the generated chunk data (more reliable than getBlockData before rendering)
    getBlockType(x, y, z) {
         const xi = Math.floor(x);
         const yi = Math.floor(y);
         const zi = Math.floor(z);

         // Check bounds
         if (yi < 0 || yi >= WORLD_HEIGHT) return blocks.AIR; // Treat outside world height as air

         const chunkX = Math.floor(xi / CHUNK_SIZE);
         const chunkZ = Math.floor(zi / CHUNK_SIZE);
         const chunkKey = `${chunkX},${chunkZ}`;

         const chunk = this.chunks[chunkKey];

         // If chunk exists and has data (generated or rendered)
         if (chunk && chunk.data) {
             const localX = xi - chunkX * CHUNK_SIZE;
             const localZ = zi - chunkZ * CHUNK_SIZE;
             // Ensure local coords are valid (should be by calculation)
             if (localX >= 0 && localX < CHUNK_SIZE && localZ >= 0 && localZ < CHUNK_SIZE) {
                  // Add safety check for y index just in case
                 if (yi >= 0 && yi < WORLD_HEIGHT) {
                    try {
                        return chunk.data[localX][yi][localZ];
                    } catch (e) {
                         console.error(`Error accessing chunk data at [${localX}][${yi}][${localZ}] in chunk ${chunkKey}`);
                         return blocks.AIR; // Treat error as air
                    }
                }
             }
         }
         // If chunk doesn't exist or has no data, treat as air
        return blocks.AIR;
    }

    // Check if block at position is solid (using getBlockType for reliability)
    isSolidBlock(x, y, z) {
        const blockType = this.getBlockType(x, y, z);
        // Air and water are definitely not solid
        if (blockType === blocks.AIR || blockType === blocks.WATER_STILL /* add leaves etc.? */) {
            return false;
        }
        // Get definition
        const blockDef = getBlockDef(blockType);
        // Return true only if definition exists and its 'solid' property is explicitly true
        // Otherwise (missing def, missing solid prop, solid is false/undefined) return false.
        return !!(blockDef && blockDef.solid === true);
    }

    // Renamed from addBlock - focuses on creating the mesh from existing data
    addBlockMesh(x, y, z, blockId) {
        console.warn("addBlockMesh called - this function needs refactoring for merged chunk geometry.");
        // TODO: Refactor this to trigger a re-render of the relevant chunk.
        return false; // Indicate failure for now

        /* --- OLD LOGIC (REMOVE/COMMENT OUT) ---
        const xi = Math.floor(x);
        const yi = Math.floor(y);
        const zi = Math.floor(z);
        const key = `${xi},${yi},${zi}`;

        // Avoid duplicates if somehow called twice
        if (this.blocks[key]) {
             console.warn(`Mesh already exists at ${key}. Skipping add.`);
            return false;
        }

        const blockDef = getBlockDef(blockId);
        if (!blockDef || blockId === blocks.AIR) {
            return false; // Should not happen if visibility check is correct
        }

        // Use pre-calculated UVs and the shared material
        const geometry = this.createBlockGeometry(blockId);
        const material = this.baseMaterial; // Use the single shared material

        const mesh = new THREE.Mesh(geometry, material);
        mesh.position.set(xi + 0.5, yi + 0.5, zi + 0.5);
        mesh.castShadow = true;
        mesh.receiveShadow = true;
        mesh.userData = { blockId: blockId, x: xi, y: yi, z: zi }; // Store data

        this.scene.add(mesh);
        // Store reference to the mesh and its definition
        this.blocks[key] = { type: blockId, def: blockDef, mesh: mesh };
        this.meshes[key] = mesh; // Keep separate mesh lookup if needed elsewhere
        // console.log(`Added mesh for ${blockDef.name} at ${key}`);
        return true;
        */
    }

    // Helper to re-render a chunk after block updates
    rerenderChunk(chunkX, chunkZ) {
        const chunkKey = `${chunkX},${chunkZ}`;
        const chunk = this.chunks[chunkKey];
        
        if (!chunk) {
            console.error(`Cannot re-render chunk ${chunkKey}: chunk doesn't exist`);
            return false;
        }
        
        // Remove old mesh
        if (chunk.mesh) {
            this.scene.remove(chunk.mesh);
            if (chunk.mesh.geometry) {
                chunk.mesh.geometry.dispose();
            }
            chunk.mesh = null;
        }
        
        // Set the state back to 'generated' so it will be re-rendered
        chunk.state = 'generated';
        this.renderedChunks.delete(chunkKey);
        
        // Trigger a render
        this.renderChunk(chunkX, chunkZ);
        
        return true;
    }

    removeBlock(x, y, z) {
        const xi = Math.floor(x);
        const yi = Math.floor(y);
        const zi = Math.floor(z);
        const key = `${xi},${yi},${zi}`; // Key for block position

        // Update the underlying chunk data array first
        const chunkX = Math.floor(xi / CHUNK_SIZE);
        const chunkZ = Math.floor(zi / CHUNK_SIZE);
        const chunkKey = `${chunkX},${chunkZ}`;
        const chunk = this.chunks[chunkKey];
        let updatedData = false;
        if (chunk && chunk.data) {
            const localX = xi - chunkX * CHUNK_SIZE;
            const localZ = zi - chunkZ * CHUNK_SIZE;
            if (localX >= 0 && localX < CHUNK_SIZE && localZ >= 0 && localZ < CHUNK_SIZE && yi >= 0 && yi < WORLD_HEIGHT) {
                 if(chunk.data[localX][yi][localZ] !== blocks.AIR) {
                    chunk.data[localX][yi][localZ] = blocks.AIR; // Set to air in data model
                    updatedData = true;
                     console.log(`Removed block data at ${key}`);
                 }
            }
        }

        // If data was updated, the chunk mesh needs to be rebuilt.
        if (updatedData) {
            console.log(`Re-rendering chunk ${chunkKey} after block removal at ${key}`);
            this.rerenderChunk(chunkX, chunkZ);
            return true; // Data was updated
        }

        return false; // Block wasn't found in data or no data change occurred
    }

    // Place a block (player action) - Updates data and adds mesh
    placeBlock(x, y, z, blockId) {
         const xi = Math.floor(x);
         const yi = Math.floor(y);
         const zi = Math.floor(z);
         const key = `${xi},${yi},${zi}`; // Block position key

         // Basic validation
         if (yi < 0 || yi >= WORLD_HEIGHT || blockId === blocks.AIR) return false;

         // Check if position is occupied by player (simple check)
         // Note: Relies on camera being available via scene.getObjectByName
         if (this.isPositionOccupiedByPlayer(xi, yi, zi)) {
             console.log("Cannot place block where player is standing");
             return false;
         }

         // Check if block already exists at location using getBlockType
         if (this.getBlockType(xi, yi, zi) !== blocks.AIR) {
             console.log("Block already exists at location (checked data).");
             return false;
         }

         // Update the chunk data model first
         const chunkX = Math.floor(xi / CHUNK_SIZE);
         const chunkZ = Math.floor(zi / CHUNK_SIZE);
         const chunkKey = `${chunkX},${chunkZ}`;
         const chunk = this.chunks[chunkKey];

         if (!chunk || !chunk.data) {
             console.error(`Cannot place block: Chunk ${chunkKey} not loaded or generated.`);
             return false; // Cannot place block in non-existent chunk data
         }

         const localX = xi - chunkX * CHUNK_SIZE;
         const localZ = zi - chunkZ * CHUNK_SIZE;
          if (localX < 0 || localX >= CHUNK_SIZE || localZ < 0 || localZ >= CHUNK_SIZE) {
              console.error("Calculated local chunk coordinates out of bounds.");
              return false; // Should not happen
          }

         // Update data model
         chunk.data[localX][yi][localZ] = blockId;
         console.log(`Placed block data ${blockId} at ${key}`);

        // Re-render the chunk
        console.log(`Re-rendering chunk ${chunkKey} after block placement at ${key}`);
        this.rerenderChunk(chunkX, chunkZ);

        return true; // Data was updated
    }

    // Helper method to check if a block position is occupied by the player
    isPositionOccupiedByPlayer(x, y, z) {
        // Get player position - assumes camera is available and positioned correctly
        const camera = this.scene.getObjectByName('camera');
        if (!camera) return false;

        const playerPos = camera.position;
        const playerHeight = 1.8; // Approx height
        const playerRadius = 0.3; // Approx radius

        // Player's bounding box coordinates
        const playerMinX = playerPos.x - playerRadius;
        const playerMaxX = playerPos.x + playerRadius;
        const playerMinY = playerPos.y - playerHeight; // Feet
        const playerMaxY = playerPos.y; // Eyes / Top of head
        const playerMinZ = playerPos.z - playerRadius;
        const playerMaxZ = playerPos.z + playerRadius;

        // Block's bounding box coordinates
        const blockMinX = x;
        const blockMaxX = x + 1;
        const blockMinY = y;
        const blockMaxY = y + 1;
        const blockMinZ = z;
        const blockMaxZ = z + 1;

        // Check for overlap (AABB collision)
        const overlapX = playerMinX < blockMaxX && playerMaxX > blockMinX;
        const overlapY = playerMinY < blockMaxY && playerMaxY > blockMinY;
        const overlapZ = playerMinZ < blockMaxZ && playerMaxZ > blockMinZ;

        return overlapX && overlapY && overlapZ;
    }

    // Update world chunks based on player position
    updateChunks(playerPosition) {
        // Use the flag 'isSafeToApplyGravity' which now indicates initial RENDER is complete
        if (!playerPosition || !this.isSafeToApplyGravity) {
            // Don't update chunks or check safety if initial load/render isn't done
            return { action: 'none' };
        }

        // --- Player Safety Check ---
        if (this.isPlayerInUnsafePosition(playerPosition)) {
        if (this.lastSafePosition) {
                console.warn("Player in unsafe position! Teleporting back to safety.");
                 // --- DISABLED TELEPORT ---
                 // return { action: 'teleport', position: this.lastSafePosition.clone() };
                 // --- DISABLED TELEPORT ---
            } else {
                // This should ideally not happen after initial render is complete,
                // but as a fallback...
                 console.error("Player in unsafe position, but no last safe position known! Teleporting to origin. (Teleport Disabled)");
                 const safeFallback = new THREE.Vector3(0.5, WORLD_HEIGHT, 0.5);
                 // Don't set lastSafePosition here if teleport is disabled, allow physics to try and resolve
                 // this.lastSafePosition = safeFallback.clone(); // Set it immediately
                 // --- DISABLED TELEPORT ---
                 // return { action: 'teleport', position: safeFallback };
                 // --- DISABLED TELEPORT ---
            }
        }

        // --- Chunk Loading/Unloading Logic ---
        const playerChunkX = Math.floor(playerPosition.x / CHUNK_SIZE);
        const playerChunkZ = Math.floor(playerPosition.z / CHUNK_SIZE);

        // Update last known chunk if changed
        if (playerChunkX !== this.lastPlayerChunk.x || playerChunkZ !== this.lastPlayerChunk.z) {
            // console.log(`Player moved to chunk (${playerChunkX}, ${playerChunkZ})`); // Reduce noise
            this.lastPlayerChunk = { x: playerChunkX, z: playerChunkZ };
        }

        // Identify chunks needed based on render distance
        const neededChunks = new Set();
        for (let cx = playerChunkX - this.renderDistance; cx <= playerChunkX + this.renderDistance; cx++) {
            for (let cz = playerChunkZ - this.renderDistance; cz <= playerChunkZ + this.renderDistance; cz++) {
                neededChunks.add(`${cx},${cz}`);
            }
        }

        // Request generation for needed chunks that are missing/unloaded
        let requestedNew = 0;
        for (const chunkKey of neededChunks) {
             const chunk = this.chunks[chunkKey];
             // Request if unloaded or previously errored (maybe retry?)
             if (!chunk || chunk.state === 'unloaded' || chunk.state === 'error') {
                 const [cx, cz] = chunkKey.split(',').map(Number);
                 const distance = Math.sqrt(Math.pow(cx - playerChunkX, 2) + Math.pow(cz - playerChunkZ, 2));
                 this.queueChunkGeneration(cx, cz, distance);
                 requestedNew++;
             }
        }
        // If new chunks were queued, process the request queue
        if (requestedNew > 0) {
            this.processChunkRequestQueue();
        }

        // Render chunks that are generated but not rendered within distance
        for (const chunkKey of neededChunks) {
            const chunk = this.chunks[chunkKey];
            if (chunk && chunk.state === 'generated' && !this.renderedChunks.has(chunkKey)) {
                const [cx, cz] = chunkKey.split(',').map(Number);
                this.renderChunk(cx, cz);
            }
        }

        // --- Unloading Logic ---
        const unloadDistance = this.renderDistance + 3; // Unload further away (Increased buffer from +2)
        const chunksToUnload = [];

        for (const chunkKey of this.renderedChunks) {
            if (neededChunks.has(chunkKey)) continue; // Don't unload needed chunks

            const [cx, cz] = chunkKey.split(',').map(Number);
            const manhattanDistance = Math.abs(cx - playerChunkX) + Math.abs(cz - playerChunkZ);

            if (manhattanDistance > unloadDistance) {
                chunksToUnload.push({ key: chunkKey, distance: manhattanDistance });
            }
        }

        // Sort chunks to unload, furthest first
        chunksToUnload.sort((a, b) => b.distance - a.distance);

        // Unload only one chunk per frame to avoid hitches
        if (chunksToUnload.length > 0) {
            const chunkKeyToUnload = chunksToUnload[0].key;
            const [cx, cz] = chunkKeyToUnload.split(',').map(Number);
                this.unloadChunk(cx, cz);
        }

         // --- Update Safe Position ---
         // Check if player is on ground and update lastSafePosition
         // This now happens only AFTER initial render is complete
        if (this.isPlayerOnGround(playerPosition)) {
             // Initialize or update the last safe position
             if (!this.lastSafePosition) {
                 console.log("Setting initial safe position.");
             }
            this.lastSafePosition = playerPosition.clone();
         } else if (!this.lastSafePosition) {
              // If still null after gravity is enabled, player likely spawned mid-air.
              // Wait for them to land. Log potentially?
              // console.log("Waiting for player to land to set initial safe position...");
         }

        // Emergency check: If player's current chunk isn't loaded/rendered, request/render immediately
        this.ensurePlayerChunkIsLoaded(playerChunkX, playerChunkZ);

        return { action: 'none' }; // Default return
    }

    // Check if player is standing on solid ground (relies on block data)
    isPlayerOnGround(position) {
        // Check slightly below player's feet position
        const checkY = position.y - 1.9; // Adjusted check position (below player model base)
        const blockX = Math.floor(position.x);
        const blockY = Math.floor(checkY);
        const blockZ = Math.floor(position.z);

        // Use the reliable isSolidBlock method which checks the data model
        return this.isSolidBlock(blockX, blockY, blockZ);
        /* --- OLD LOGIC (Removed mesh check) ---
        const blockType = this.getBlockType(blockX, blockY, blockZ);

        if (blockType !== blocks.AIR && blockType !== undefined) {
            const blockDef = getBlockDef(blockType);
            if (blockDef && blockDef.solid === true) {
                 // CRUCIAL Check removed: Now only relies on data, not mesh presence.
                 // const blockData = this.getBlockData(blockX, blockY, blockZ);
                 // return blockData && blockData.mesh;
                 return true; // Considered grounded if data says solid block exists
            }
        }
        return false;
        */
    }

    // More robust check for unsafe positions
    isPlayerInUnsafePosition(position) {
        // Check 1: Falling too fast (check velocity if available, otherwise large Y delta)
        if (this.lastSafePosition) {
            const verticalDistance = position.y - this.lastSafePosition.y;
            if (verticalDistance < -30) { // Fallen very far since last safe point
                console.warn("Unsafe: Large negative Y delta detected.");
                return true;
            }
        } else {
            // If no safe position yet (initial fall), check absolute position isn't too low
            if (position.y < -10) { // Arbitrary low threshold before first safe point
                console.warn(`Unsafe: Player Y (${position.y.toFixed(1)}) too low before initial safe point.`);
                return true;
            }
        }

        // Check 2: Player feet are below bedrock or way too high (sanity check)
        const playerFeetY = position.y - 1.8;
        if (playerFeetY < -1 || playerFeetY > WORLD_HEIGHT + 50) {
            console.warn(`Unsafe: Player feet Y out of bounds (${playerFeetY.toFixed(1)}).`);
            return true;
        }

        // Check 3: Player center/feet is inside a solid block (using isSolidBlock which checks data)
        const centerX = Math.floor(position.x);
        const centerY = Math.floor(position.y - 0.9); // Check around torso height
        const centerZ = Math.floor(position.z);
        if (this.isSolidBlock(centerX, centerY, centerZ)) {
            // Removed mesh check: Rely only on data model for safety check
            console.warn(`Unsafe: Player center inside solid block data at (${centerX}, ${centerY}, ${centerZ})`);
            return true;
        }
        // Check feet position too
        const feetBlockY = Math.floor(playerFeetY);
        if (this.isSolidBlock(centerX, feetBlockY, centerZ)) {
            // Removed mesh check: Rely only on data model for safety check
            console.warn(`Unsafe: Player feet inside solid block data at (${centerX}, ${feetBlockY}, ${centerZ})`);
            return true;
        }

        return false; // Position seems safe for now
    }

    // Ensures the specific chunk the player is currently in is loaded or requested.
    ensurePlayerChunkIsLoaded(playerChunkX, playerChunkZ) {
        const chunkKey = `${playerChunkX},${playerChunkZ}`;
        const chunk = this.chunks[chunkKey];

        // If chunk doesn't exist, is unloaded, or errored, request generation immediately
        if (!chunk || chunk.state === 'unloaded' || chunk.state === 'error') {
            console.warn(`CRITICAL: Player chunk (${playerChunkX}, ${playerChunkZ}) not loaded/generated. Requesting now.`);
             // Use requestChunkGeneration which handles duplicates and sends msg to worker
            if(this.requestChunkGeneration(playerChunkX, playerChunkZ)) {
                // If a new request was sent, try to process queue immediately
                this.processChunkRequestQueue();
            }
        }
        // If chunk exists and is generated but not rendered, render it immediately
        else if (chunk.state === 'generated' && !this.renderedChunks.has(chunkKey)) {
            console.warn(`CRITICAL: Player chunk (${playerChunkX}, ${playerChunkZ}) generated but not rendered. Rendering now.`);
            this.renderChunk(playerChunkX, playerChunkZ);
        }
    }

    // Unload a chunk - remove meshes and mark state
    unloadChunk(chunkX, chunkZ) {
        const chunkKey = `${chunkX},${chunkZ}`;

        // Safety check: Never unload player's current chunk (should be handled by caller distance check)
        if (chunkX === this.lastPlayerChunk.x && chunkZ === this.lastPlayerChunk.z) {
            // console.log(`Prevented unloading player's current chunk (${chunkX}, ${chunkZ})`);
            return;
        }

        const chunk = this.chunks[chunkKey];
        // Only unload if it's actually rendered AND has a mesh
        if (!chunk || chunk.state !== 'rendered' || !this.renderedChunks.has(chunkKey)) {
            return;
        }

        // console.log(`Unloading chunk at (${chunkX}, ${chunkZ})`); // Reduce noise

        // Remove the single chunk mesh if it exists
        if (chunk.mesh) {
            this.scene.remove(chunk.mesh);
            // Dispose geometry
            if (chunk.mesh.geometry) {
                chunk.mesh.geometry.dispose();
            }
            chunk.mesh = null; // Clear reference
        } else {
             // This might happen if the chunk was rendered but had no visible blocks
             // console.log(`Chunk ${chunkKey} was marked rendered but had no mesh to remove.`);
        }

        /* --- OLD LOGIC (REMOVE/COMMENT OUT) ---
        // Remove all block meshes associated with this chunk
        for (let x = 0; x < CHUNK_SIZE; x++) {
            for (let y = 0; y < WORLD_HEIGHT; y++) {
                for (let z = 0; z < CHUNK_SIZE; z++) {
                    const worldX = chunkX * CHUNK_SIZE + x;
                    const worldZ = chunkZ * CHUNK_SIZE + z;
                    const key = `${worldX},${y},${worldZ}`;
                    // Use removeBlock logic which handles scene removal and disposal
                    if (this.blocks[key]) {
                         // Call removeBlock without updating chunk data (already handled by unload)
                         const blockData = this.blocks[key];
                         if (blockData && blockData.mesh) {
                             this.scene.remove(blockData.mesh);
                             if (blockData.mesh.geometry) {
                                 blockData.mesh.geometry.dispose();
                             }
                             delete this.blocks[key];
                             delete this.meshes[key];
                         }
                    }
                }
            }
        }
        */

        // Mark chunk as unloaded (keep data) and remove from rendered set
        chunk.state = 'unloaded'; // Keep generated data in memory
        this.renderedChunks.delete(chunkKey);

        // To truly free memory, we could delete the data too:
        // delete this.chunks[chunkKey];
        // But keeping it allows faster reloading if player returns.
    }

}

// Ensure `blocks` is imported correctly for use in worker init message
// console.log("Block definitions loaded for world:", blocks); // Reduce noise 