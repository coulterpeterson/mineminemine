import * as THREE from 'three';
import { blocks, blockDefs, getBlockDef, getBlockFaceUVs } from './blockRegistry.js';

// Simple Cube Geometry (reused for all standard blocks)
const unitCubeGeo = new THREE.BoxGeometry(1, 1, 1);

// Placeholder for world generation and block management
export class World {
    constructor(scene, textureAtlas, uvMap) {
        this.scene = scene;
        this.textureAtlas = textureAtlas; // The main texture atlas
        this.uvMap = uvMap;           // Map of texture names to UV coords
        this.blocks = {};             // Store block data { type, mesh, ... }
        this.meshes = {};             // Store just the meshes for quick lookup

        // Create a base material using the atlas
        this.baseMaterial = new THREE.MeshLambertMaterial({
            map: this.textureAtlas,
            side: THREE.FrontSide, // Only render front faces
            alphaTest: 0.1, // Prevent transparent parts of textures rendering black outlines
            transparent: true, // Allow transparency (e.g., leaves, glass)
        });
    }

    // Creates the geometry for a standard cube block with correct UVs
    createBlockGeometry(blockId) {
        const geo = unitCubeGeo.clone(); // Clone the base geometry
        const uvs = []; // We will build the UV array manually

        // Map faces (order depends on BoxGeometry creation: px, nx, py, ny, pz, nz)
        // Corresponds to: right, left, top, bottom, front, back
        const faceOrder = ['right', 'left', 'top', 'bottom', 'front', 'back'];

        for (const face of faceOrder) {
            const faceUVs = getBlockFaceUVs(blockId, face);
            if (faceUVs) {
                // The order of these UV pairs needs to match the vertex order
                // generated by BoxGeometry for each face.
                // After experimentation, the following orders seem correct:

                if (face === 'top' || face === 'bottom') {
                    // Order for Top/Bottom faces (Y +/-)
                    uvs.push(faceUVs.u0, faceUVs.v1); // Top-left (of the texture)
                    uvs.push(faceUVs.u1, faceUVs.v1); // Top-right
                    uvs.push(faceUVs.u0, faceUVs.v0); // Bottom-left
                    uvs.push(faceUVs.u1, faceUVs.v0); // Bottom-right
                } else {
                    // Order for Side faces (X +/-, Z +/-)
                    // Try: Top-left -> Top-right -> Bottom-left -> Bottom-right
                    uvs.push(faceUVs.u0, faceUVs.v1); // Top-left
                    uvs.push(faceUVs.u1, faceUVs.v1); // Top-right
                    uvs.push(faceUVs.u0, faceUVs.v0); // Bottom-left
                    uvs.push(faceUVs.u1, faceUVs.v0); // Bottom-right
                }
            } else {
                // Default/missing texture UVs (small magenta square?)
                console.warn(`Missing UVs for block ${blockId}, face ${face}. Using fallback.`);
                // Define a tiny area in the atlas, assuming magenta fill was used for errors
                const missingUVs = { u0: 0, v0: 0, u1: 0.001, v1: 0.001 };
                uvs.push(missingUVs.u0, missingUVs.v1);
                uvs.push(missingUVs.u1, missingUVs.v1);
                uvs.push(missingUVs.u0, missingUVs.v0);
                uvs.push(missingUVs.u1, missingUVs.v0);
            }
        }

        // Replace the automatically generated UV attribute with our corrected one
        geo.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
        geo.computeVertexNormals(); // Good practice after modifying attributes
        return geo;
    }

    // Initial simple generation - flat plane with textures
    generate() {
        console.log("Generating initial world with textures...");
        const groundSize = 20;
        const groundLevel = 0;

        for (let x = -groundSize / 2; x < groundSize / 2; x++) {
            for (let z = -groundSize / 2; z < groundSize / 2; z++) {
                // Place bedrock at y= -1
                this.addBlock(x, -1, z, blocks.BEDROCK);
                // Place stone below ground
                this.addBlock(x, groundLevel -1, z, blocks.STONE)
                // Place grass on top
                this.addBlock(x, groundLevel, z, blocks.GRASS);
            }
        }
        console.log(`Generated initial blocks.`);
    }

    getBlock(x, y, z) {
        const key = `${Math.floor(x)},${Math.floor(y)},${Math.floor(z)}`;
        return this.blocks[key];
    }
    
    // Get just the block ID at a position
    getBlockType(x, y, z) {
        const block = this.getBlock(x, y, z);
        return block ? block.type : blocks.AIR;
    }

    // Check if a block position is suitable for player to stand on
    isSolidBlock(x, y, z) {
        const block = this.getBlock(x, y, z);
        return block && block.def && !block.def.transparent;
    }

    addBlock(x, y, z, blockId) {
        const xi = Math.floor(x);
        const yi = Math.floor(y);
        const zi = Math.floor(z);
        const key = `${xi},${yi},${zi}`;

        // Don't allow placing blocks where the player is
        // This could be improved with more sophisticated collision detection
        if (this.isPositionOccupiedByPlayer(xi, yi, zi)) {
            console.log("Cannot place block where player is standing");
            return false;
        }

        if (this.blocks[key]) {
            // console.warn(`Block already exists at ${key}. Replacing.`);
            this.removeBlock(xi, yi, zi); // Remove existing mesh first
        }

        const blockDef = getBlockDef(blockId);
        if (!blockDef || blockId === blocks.AIR) {
            // console.log(`Skipping adding AIR block at ${key}`);
            return false; // Don't add air blocks or unknown blocks
        }

        // Use pre-calculated UVs and the shared material
        const geometry = this.createBlockGeometry(blockId);
        // Use the single shared material for performance
        const material = this.baseMaterial;

        const mesh = new THREE.Mesh(geometry, material);
        mesh.position.set(xi + 0.5, yi + 0.5, zi + 0.5);
        mesh.castShadow = true;
        mesh.receiveShadow = true;
        mesh.userData = { blockId: blockId, x: xi, y: yi, z: zi }; // Store data on mesh

        this.scene.add(mesh);
        this.blocks[key] = { type: blockId, def: blockDef, mesh: mesh };
        this.meshes[key] = mesh;
        // console.log(`Added block ${blockDef.name} at ${key}`);
        return true;
    }

    removeBlock(x, y, z) {
        const xi = Math.floor(x);
        const yi = Math.floor(y);
        const zi = Math.floor(z);
        const key = `${xi},${yi},${zi}`;
        const blockData = this.blocks[key];

        if (blockData && blockData.mesh) {
            this.scene.remove(blockData.mesh);

            // Dispose geometry IF it's unique per block (which it is now)
            // If we move to InstancedMesh or merged geometries later, this needs to change.
            if (blockData.mesh.geometry) {
                 blockData.mesh.geometry.dispose();
            }

            // Don't dispose the shared material
            // if (blockData.mesh.material) {
            //     blockData.mesh.material.dispose();
            // }

            delete this.blocks[key];
            delete this.meshes[key];
            // console.log(`Removed block at ${key}`);
            return true;
        } else {
            // console.warn(`No block found at ${key} to remove.`);
            return false;
        }
    }
    
    // Helper method to check if a block position is where the player is standing
    // This is a simple approximation - could be improved with proper collision detection
    isPositionOccupiedByPlayer(x, y, z) {
        // Get player position - assumes camera is at player's eyes
        const camera = this.scene.getObjectByName('camera');
        if (!camera) return false;
        
        const playerPos = camera.position.clone();
        
        // Check if block is within player's bounds
        // Player is approximately 1.8 blocks tall and 0.6 blocks wide
        const playerMinX = playerPos.x - 0.3;
        const playerMaxX = playerPos.x + 0.3;
        const playerMinY = playerPos.y - 1.8; // Player's feet
        const playerMaxY = playerPos.y;       // Player's eyes
        const playerMinZ = playerPos.z - 0.3;
        const playerMaxZ = playerPos.z + 0.3;
        
        return (
            x >= Math.floor(playerMinX) && x <= Math.floor(playerMaxX) &&
            y >= Math.floor(playerMinY) && y <= Math.floor(playerMaxY) &&
            z >= Math.floor(playerMinZ) && z <= Math.floor(playerMaxZ)
        );
    }

    // --- Future Methods ---
    // update(playerPos) { /* For chunk loading/unloading */ }
    // getChunk(chunkX, chunkZ) { /* Manage chunk data */ }
    // generateChunk(chunkX, chunkZ) { /* Actual procedural generation */ }
} 